# It takes the seq ids (Ensembl transcripts) from Blastp comparison and then the seq having identity and coverage over threshold are compared for results generated by Interpro. This script also creates different files for differnt Interpro tools.
# Blastp: identity, and seq & query coverage
# Firstly, it compares the exact matches
# Secondly, it compares if the part of the seq has moved
# Thirdly, it compares if the type of profiles and patterns are conserved even if their frequency is different
# This script stores the data structure with Blast and interpro data for all the protein pairs that will be used in further analyses.
# To differentiate between the pairs when 1 seq doesn't have a prediciton and when both the seqs don't have a prediciton: NP1, NP2, NP12

use strict;
use warnings;
use List::MoreUtils qw(uniq);
use Getopt::Long;
use Cwd;
use JSON::XS qw(encode_json decode_json);
use File::Slurp qw(read_file write_file);

#use Data::Dumper;		#for developmental only
#use Array::Utils qw(:all);
#use Array::Utils;
#use File::Find::Rule;
#use Storable qw(store);


################Flags START######################

my ($interpro_file, $blast_file, $bi_do, $out_path, $help);

$bi_do = "bi_do.json";
$out_path = getcwd;

GetOptions(
	'interpro|i=s' => \$interpro_file,
	'blast|b=s' => \$blast_file,
	'bi_do|bi=s' => \$bi_do,
	'out_path|o=s' => \$out_path,
	'help|h' => \$help,
) or die usage();

if($help){usage();}
else
{
	if (not defined $interpro_file)
	{print STDERR "Error Argument '--interpro' or '-i' is mandatory\n";
		usage();}
	elsif (not defined $blast_file)
	{print STDERR "Error Argument '--blast' or '-b' is mandatory\n";
		usage();}
}

sub usage {
    $0 =~ s/.+\///g;
	print "\nUsage: $0 --interpro <filename> --blast <filename> [--out_path <out path>] [--bi_do <filename>]\n";
    print "Usage: $0 -i <filename> -b <filename> [-o <out path>] [-bi <filename>]\n";
    print "       $0 --help\n";
    print "       $0 -h\n";
	print "
	interpro|i      Path and filename to the Interpro result file
	
	blast|b         Path and filename to the BLAST result file
	
	bi_do|bi        Filename for the data object to be created using this program
	                Default name 'bi_do.json'
	
	out_path|o      Out path for the bi_do
	                Default path is the current folder
	
	help|h          To invoke this help\n";
	exit
}

###########################Flags END##################

if($bi_do =~ m/\.data/){}
else
{
	$bi_do = $bi_do.".data";
}

print "Running with\n\tInterpro-> $interpro_file\n\tBlast-> $blast_file\nCreating\n\tData str object-> $bi_do\nAt\n\t$out_path\n\n";

##############

open(my $interpro, $interpro_file) or die "Could not open file '$interpro_file' $!";
print "Reading Interpro\n";

my (%hash);

while(<$interpro>)
{
	chomp $_;
	my @arr = split /\t/, $_;
	
	if(exists $hash{$arr[0]})
	{
		if(exists $hash{$arr[0]}{$arr[3]})
		{
			push @{$hash{$arr[0]}{$arr[3]}}, $arr[6].'-'.$arr[7].'_'.$arr[4];
		}
		else
		{
			$hash{$arr[0]}{$arr[3]} = [$arr[6].'-'.$arr[7].'_'.$arr[4]];
		}
	}
	else
	{
		$hash{$arr[0]}{$arr[3]} = [$arr[6].'-'.$arr[7].'_'.$arr[4]];
	}
}
print "\tDone reading\nProcessing Interpro data\t";
my (%ip1, %ip2, %ip3);			#ip = interpro

foreach my $k1(keys %hash)
{
	foreach my $k2(keys %{$hash{$k1}})
	{
		no warnings;						#becasue using numerical sort on alphanumeric strings; with alphabetic sort the numbers precedding the string are sorted per position and not face value
		my @a = sort {$a <=> $b || $a cmp $b } @{$hash{$k1}{$k2}};
		
		s{[0-9]+\-[0-9]+\_}{}g foreach @a;
		
		my $str1 = join '|', @a;			#all predicted patterns and profiles in order of apperance on the seq
		$ip1{$k1}{$k2} = [$str1];			#to compare for exact matches
		
		$ip2{$k1}{$k2} = [@a];				#to compare for proteins with part of seq moved; the number of patterns and profiles remain same but they change positions
		
		my @a1 = uniq @a;
		my @a2 = sort(@a1);
		my $str2 = join '|', @a2;
		$ip3{$k1}{$k2} = [$str2];			#to compare when the number of patterns and profiles change but the types remain constant
	}
}
print "\tDone\nNow reading BLAST file and concurrently finding similar seqs\n";

#my $path_blast = "/ngs-data/analysis/eutoxrisk/isozymes_isoforms/all_protein_transcripts_blast/";
#my @f_blast = File::Find::Rule->file()
#					->name( '*align*' )			##Give the text to match for the file name here
#					->in( $path_blast );
#

my %processed;
my @ip_tools = ('CDD', 'Coils', 'Gene3D', 'Hamap', 'MobiDBLite', 'Pfam', 'PIRSF', 'PRINTS', 'ProSitePatterns', 'ProSiteProfiles', 'SFLD', 'SMART', 'SUPERFAMILY', 'TIGRFAM');
my %res;

#foreach my $blast_file (@f_blast)
#{
#	print "\t$blast_file\n";
	open(my $blast, $blast_file) or die "Could not open file '$blast_file' $!";
	while(<$blast>)
	{
		if($_ =~ m/\#/){next;}
		elsif($_ =~ m/(unnamed)/){next;}
		else
		{
			chomp;
			my $s = $_;
			my @arr = split /\t/, $s;
#			$string =~ s/\r|\n//g;
			
			my $string = $arr[2].' '.(($arr[3]/$arr[12])*100).' '.(($arr[3]/$arr[13])*100).' '.(($arr[5]/$arr[3])*100);		#To find the subject or query coverage, alignment length is divided by them but in case of gaps, gaps are divided by alignment length to find the percent of alignment length which has gaps

# Fields: query id, subject id, % identity, alignment length, mismatches, gap opens, q. start, q. end, s. start, s. end, evalue, bit score, query length, subject length"
			
			if($arr[0] eq $arr[1]){next;}
			elsif(exists $processed{$arr[0].'-'.$arr[1]}){next;}
			elsif(exists $processed{$arr[1].'-'.$arr[0]}){next;}
#			elsif($arr[2]<90 || (($arr[3]/$arr[12])*100)<90 || (($arr[3]/$arr[12])*100)>110 || (($arr[3]/$arr[13])*100)<90 || (($arr[3]/$arr[13])*100)>110){next;}		#for development only
			else
			{
				ip_match1(@arr, $string);
				$processed{$arr[0].'-'.$arr[1]} = undef;
			}
		}
	}
#}

#to compare for exact matches
sub ip_match1
{
	my @arr = @_;
	my $key1 = $arr[0];
	my $key3 = $arr[1];
	my $k_id = $key1.'-'.$key3;
	
	my $string = pop @arr;
	
	foreach my $key2 (@ip_tools)
	{
		if(exists $ip1{$key1}{$key2})
		{
			if(exists $ip1{$key3}{$key2})
			{
				if(@{$ip1{$key1}{$key2}}[0] eq @{$ip1{$key3}{$key2}}[0])
				{
					make_res($k_id, $string, "STONM");
				}
				else
				{
					ip_match2(@arr, $string, $key2);
				}
			}
			else
			{
				make_res($k_id, $string, "NP2");		#not present in second id
			}
		}
		else
		{
			if(exists $ip1{$key3}{$key2})
			{
				make_res($k_id, $string, "NP1");		#not present in first id
			}
			else
			{
				make_res($k_id, $string, "NP12");		#not present in both the ids
			}
		}
	}
}

#to compare for proteins with part of seq moved
sub ip_match2
{
	my @arr = @_;
	my $key1 = $arr[0];
	my $key3 = $arr[1];
	my $key2 = pop @arr;
	my $k_id = $key1.'-'.$key3;
	
	my $string = pop @arr;
	
	if(scalar(@{$ip2{$key1}{$key2}}) == scalar(@{$ip2{$key3}{$key2}}))
	{
		my @same = intersect(@{$ip2{$key1}{$key2}}, @{$ip2{$key3}{$key2}});
		if(scalar(@same) == scalar(@{$ip2{$key1}{$key2}}))
		{
			make_res($k_id, $string, "STNM");
		}
		else
		{
			ip_match3(@arr, $string, $key2);
		}
	}
	else
	{
		ip_match3(@arr, $string, $key2);
	}
}

#to compare when the number of patterns and profiles change but the types remain constant
sub ip_match3
{
	my @arr = @_;
	my $key1 = $arr[0];
	my $key3 = $arr[1];
	my $key2 = pop @arr;
	my $k_id = $key1.'-'.$key3;
	
	my $string = pop @arr;
	
	if(@{$ip3{$key1}{$key2}}[0] eq @{$ip3{$key3}{$key2}}[0])
	{
		make_res($k_id, $string, "STM");
	}
	else
	{
		make_res($k_id, $string, "NM");
	}
}


sub make_res
{
	my $k = $_[0];
	my @str = split /\s/, $_[1];
	push @str, $_[2];
	
	if(exists $res{$k})
	{
		push @{$res{$k}}, $_[2];
	}
	else
	{
		$res{$k} = [@str];
	}
}

print "\tDone\nSaving the data structure\n";
my $outfile =  join('/', $out_path, $bi_do);

{
    my $json = encode_json \%res;
    write_file($filename, { binmode => ':raw' }, $json);
}

print "\tDone\nFinished\n";
